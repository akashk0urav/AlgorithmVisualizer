{"ast":null,"code":"import _e from \"@monaco-editor/loader\";\nimport { memo as Tt } from \"react\";\nimport kt, { useState as rt, useRef as k, useCallback as ot, useEffect as nt } from \"react\";\nimport St from \"@monaco-editor/loader\";\nimport { memo as yt } from \"react\";\nimport K from \"react\";\nvar lt = {\n    wrapper: {\n      display: \"flex\",\n      position: \"relative\",\n      textAlign: \"initial\"\n    },\n    fullWidth: {\n      width: \"100%\"\n    },\n    hide: {\n      display: \"none\"\n    }\n  },\n  v = lt;\nimport mt from \"react\";\nvar at = {\n    container: {\n      display: \"flex\",\n      height: \"100%\",\n      width: \"100%\",\n      justifyContent: \"center\",\n      alignItems: \"center\"\n    }\n  },\n  Y = at;\nfunction Mt(_ref) {\n  let {\n    children: t\n  } = _ref;\n  return mt.createElement(\"div\", {\n    style: Y.container\n  }, t);\n}\nvar Z = Mt;\nvar $ = Z;\nfunction Et(_ref2) {\n  let {\n    width: t,\n    height: r,\n    isEditorReady: n,\n    loading: e,\n    _ref: a,\n    className: m,\n    wrapperProps: E\n  } = _ref2;\n  return K.createElement(\"section\", {\n    style: {\n      ...v.wrapper,\n      width: t,\n      height: r\n    },\n    ...E\n  }, !n && K.createElement($, null, e), K.createElement(\"div\", {\n    ref: a,\n    style: {\n      ...v.fullWidth,\n      ...(!n && v.hide)\n    },\n    className: m\n  }));\n}\nvar tt = Et;\nvar H = yt(tt);\nimport { useEffect as xt } from \"react\";\nfunction Ct(t) {\n  xt(t, []);\n}\nvar b = Ct;\nimport { useEffect as gt, useRef as Rt } from \"react\";\nfunction ht(t, r) {\n  let n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !0;\n  let e = Rt(!0);\n  gt(e.current || !n ? () => {\n    e.current = !1;\n  } : t, r);\n}\nvar l = ht;\nfunction h() {}\nfunction R(t, r, n, e) {\n  return Dt(t, e) || bt(t, r, n, e);\n}\nfunction Dt(t, r) {\n  return t.editor.getModel(et(t, r));\n}\nfunction bt(t, r, n, e) {\n  return t.editor.createModel(r, n, e ? et(t, e) : void 0);\n}\nfunction et(t, r) {\n  return t.Uri.parse(r);\n}\nfunction Ot(_ref3) {\n  let {\n    original: t,\n    modified: r,\n    language: n,\n    originalLanguage: e,\n    modifiedLanguage: a,\n    originalModelPath: m,\n    modifiedModelPath: E,\n    keepCurrentOriginalModel: S = !1,\n    keepCurrentModifiedModel: N = !1,\n    theme: x = \"light\",\n    loading: P = \"Loading...\",\n    options: y = {},\n    height: V = \"100%\",\n    width: z = \"100%\",\n    className: F,\n    wrapperProps: j = {},\n    beforeMount: A = h,\n    onMount: q = h\n  } = _ref3;\n  let [M, O] = rt(!1),\n    [T, s] = rt(!0),\n    u = k(null),\n    c = k(null),\n    w = k(null),\n    d = k(q),\n    o = k(A),\n    D = k(!1);\n  b(() => {\n    let i = St.init();\n    return i.then(f => (c.current = f) && s(!1)).catch(f => f?.type !== \"cancelation\" && console.error(\"Monaco initialization: error:\", f)), () => u.current ? I() : i.cancel();\n  }), l(() => {\n    if (u.current && c.current) {\n      let i = u.current.getOriginalEditor(),\n        f = R(c.current, t || \"\", e || n || \"text\", m || \"\");\n      f !== i.getModel() && i.setModel(f);\n    }\n  }, [m], M), l(() => {\n    if (u.current && c.current) {\n      let i = u.current.getModifiedEditor(),\n        f = R(c.current, r || \"\", a || n || \"text\", E || \"\");\n      f !== i.getModel() && i.setModel(f);\n    }\n  }, [E], M), l(() => {\n    let i = u.current.getModifiedEditor();\n    i.getOption(c.current.editor.EditorOption.readOnly) ? i.setValue(r || \"\") : r !== i.getValue() && (i.executeEdits(\"\", [{\n      range: i.getModel().getFullModelRange(),\n      text: r || \"\",\n      forceMoveMarkers: !0\n    }]), i.pushUndoStop());\n  }, [r], M), l(() => {\n    u.current?.getModel()?.original.setValue(t || \"\");\n  }, [t], M), l(() => {\n    let {\n      original: i,\n      modified: f\n    } = u.current.getModel();\n    c.current.editor.setModelLanguage(i, e || n || \"text\"), c.current.editor.setModelLanguage(f, a || n || \"text\");\n  }, [n, e, a], M), l(() => {\n    c.current?.editor.setTheme(x);\n  }, [x], M), l(() => {\n    u.current?.updateOptions(y);\n  }, [y], M);\n  let U = ot(() => {\n      if (!c.current) return;\n      o.current(c.current);\n      let i = R(c.current, t || \"\", e || n || \"text\", m || \"\"),\n        f = R(c.current, r || \"\", a || n || \"text\", E || \"\");\n      u.current?.setModel({\n        original: i,\n        modified: f\n      });\n    }, [n, r, a, t, e, m, E]),\n    L = ot(() => {\n      !D.current && w.current && (u.current = c.current.editor.createDiffEditor(w.current, {\n        automaticLayout: !0,\n        ...y\n      }), U(), c.current?.editor.setTheme(x), O(!0), D.current = !0);\n    }, [y, x, U]);\n  nt(() => {\n    M && d.current(u.current, c.current);\n  }, [M]), nt(() => {\n    !T && !M && L();\n  }, [T, M, L]);\n  function I() {\n    let i = u.current?.getModel();\n    S || i?.original?.dispose(), N || i?.modified?.dispose(), u.current?.dispose();\n  }\n  return kt.createElement(H, {\n    width: z,\n    height: V,\n    isEditorReady: M,\n    loading: P,\n    _ref: w,\n    className: F,\n    wrapperProps: j\n  });\n}\nvar it = Ot;\nvar wt = Tt(it);\nimport { useState as It } from \"react\";\nimport ct from \"@monaco-editor/loader\";\nfunction Pt() {\n  let [t, r] = It(ct.__getMonacoInstance());\n  return b(() => {\n    let n;\n    return t || (n = ct.init(), n.then(e => {\n      r(e);\n    })), () => n?.cancel();\n  }), t;\n}\nvar Ut = Pt;\nimport { memo as zt } from \"react\";\nimport Wt, { useState as ut, useEffect as W, useRef as C, useCallback as _t } from \"react\";\nimport Nt from \"@monaco-editor/loader\";\nimport { useEffect as Lt, useRef as vt } from \"react\";\nfunction Ht(t) {\n  let r = vt();\n  return Lt(() => {\n    r.current = t;\n  }, [t]), r.current;\n}\nvar st = Ht;\nvar _ = new Map();\nfunction Vt(_ref4) {\n  let {\n    defaultValue: t,\n    defaultLanguage: r,\n    defaultPath: n,\n    value: e,\n    language: a,\n    path: m,\n    theme: E = \"light\",\n    line: S,\n    loading: N = \"Loading...\",\n    options: x = {},\n    overrideServices: P = {},\n    saveViewState: y = !0,\n    keepCurrentModel: V = !1,\n    width: z = \"100%\",\n    height: F = \"100%\",\n    className: j,\n    wrapperProps: A = {},\n    beforeMount: q = h,\n    onMount: M = h,\n    onChange: O,\n    onValidate: T = h\n  } = _ref4;\n  let [s, u] = ut(!1),\n    [c, w] = ut(!0),\n    d = C(null),\n    o = C(null),\n    D = C(null),\n    U = C(M),\n    L = C(q),\n    I = C(),\n    i = C(e),\n    f = st(m),\n    Q = C(!1),\n    B = C(!1);\n  b(() => {\n    let p = Nt.init();\n    return p.then(g => (d.current = g) && w(!1)).catch(g => g?.type !== \"cancelation\" && console.error(\"Monaco initialization: error:\", g)), () => o.current ? pt() : p.cancel();\n  }), l(() => {\n    let p = R(d.current, t || e || \"\", r || a || \"\", m || n || \"\");\n    p !== o.current?.getModel() && (y && _.set(f, o.current?.saveViewState()), o.current?.setModel(p), y && o.current?.restoreViewState(_.get(m)));\n  }, [m], s), l(() => {\n    o.current?.updateOptions(x);\n  }, [x], s), l(() => {\n    !o.current || e === void 0 || (o.current.getOption(d.current.editor.EditorOption.readOnly) ? o.current.setValue(e) : e !== o.current.getValue() && (B.current = !0, o.current.executeEdits(\"\", [{\n      range: o.current.getModel().getFullModelRange(),\n      text: e,\n      forceMoveMarkers: !0\n    }]), o.current.pushUndoStop(), B.current = !1));\n  }, [e], s), l(() => {\n    let p = o.current?.getModel();\n    p && a && d.current?.editor.setModelLanguage(p, a);\n  }, [a], s), l(() => {\n    S !== void 0 && o.current?.revealLine(S);\n  }, [S], s), l(() => {\n    d.current?.editor.setTheme(E);\n  }, [E], s);\n  let X = _t(() => {\n    if (!(!D.current || !d.current) && !Q.current) {\n      L.current(d.current);\n      let p = m || n,\n        g = R(d.current, e || t || \"\", r || a || \"\", p || \"\");\n      o.current = d.current?.editor.create(D.current, {\n        model: g,\n        automaticLayout: !0,\n        ...x\n      }, P), y && o.current.restoreViewState(_.get(p)), d.current.editor.setTheme(E), u(!0), Q.current = !0;\n    }\n  }, [t, r, n, e, a, m, x, P, y, E]);\n  W(() => {\n    s && U.current(o.current, d.current);\n  }, [s]), W(() => {\n    !c && !s && X();\n  }, [c, s, X]), i.current = e, W(() => {\n    s && O && (I.current?.dispose(), I.current = o.current?.onDidChangeModelContent(p => {\n      B.current || O(o.current.getValue(), p);\n    }));\n  }, [s, O]), W(() => {\n    if (s) {\n      let p = d.current.editor.onDidChangeMarkers(g => {\n        let G = o.current.getModel()?.uri;\n        if (G && g.find(J => J.path === G.path)) {\n          let J = d.current.editor.getModelMarkers({\n            resource: G\n          });\n          T?.(J);\n        }\n      });\n      return () => {\n        p?.dispose();\n      };\n    }\n    return () => {};\n  }, [s, T]);\n  function pt() {\n    I.current?.dispose(), V ? y && _.set(m, o.current.saveViewState()) : o.current.getModel()?.dispose(), o.current.dispose();\n  }\n  return Wt.createElement(H, {\n    width: z,\n    height: F,\n    isEditorReady: s,\n    loading: N,\n    _ref: D,\n    className: j,\n    wrapperProps: A\n  });\n}\nvar ft = Vt;\nvar dt = zt(ft);\nvar Fe = dt;\nexport { wt as DiffEditor, dt as Editor, Fe as default, _e as loader, Ut as useMonaco };","map":{"version":3,"mappings":"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","names":["loader","memo","React","useState","useRef","useCallback","useEffect","styles","wrapper","display","position","textAlign","fullWidth","width","hide","styles_default","container","height","justifyContent","alignItems","Loading","children","style","Loading_default","MonacoContainer","isEditorReady","loading","_ref","className","wrapperProps","ref","MonacoContainer_default","useMount","effect","useMount_default","useUpdate","deps","applyChanges","isInitialMount","current","useUpdate_default","noop","getOrCreateModel","monaco","value","language","path","getModel","createModel","editor","createModelUri","Uri","parse","DiffEditor","original","modified","originalLanguage","modifiedLanguage","originalModelPath","modifiedModelPath","keepCurrentOriginalModel","keepCurrentModifiedModel","theme","options","beforeMount","onMount","setIsEditorReady","isMonacoMounting","setIsMonacoMounting","editorRef","monacoRef","containerRef","onMountRef","beforeMountRef","preventCreation","cancelable","init","then","catch","error","type","console","disposeEditor","cancel","originalEditor","getOriginalEditor","model","setModel","modifiedEditor","getModifiedEditor","getOption","EditorOption","readOnly","setValue","getValue","executeEdits","range","getFullModelRange","text","forceMoveMarkers","pushUndoStop","setModelLanguage","setTheme","updateOptions","setModels","originalModel","modifiedModel","createEditor","createDiffEditor","automaticLayout","models","dispose","DiffEditor_default","useMonaco","setMonaco","__getMonacoInstance","useMonaco_default","usePrevious","usePrevious_default","viewStates","Map","Editor","defaultValue","defaultLanguage","defaultPath","line","overrideServices","saveViewState","keepCurrentModel","onChange","onValidate","subscriptionRef","valueRef","previousPath","preventTriggerChangeEvent","set","restoreViewState","get","revealLine","autoCreatedModelPath","defaultModel","create","onDidChangeModelContent","event","changeMarkersListener","onDidChangeMarkers","uris","editorUri","uri","find","markers","getModelMarkers","resource","Editor_default","src_default"],"sources":["C:\\Users\\hp\\Desktop\\AlgorithmVisualizer-master\\node_modules\\@monaco-editor\\react\\src\\index.ts","C:\\Users\\hp\\Desktop\\AlgorithmVisualizer-master\\node_modules\\@monaco-editor\\react\\src\\DiffEditor\\index.ts","C:\\Users\\hp\\Desktop\\AlgorithmVisualizer-master\\node_modules\\@monaco-editor\\react\\src\\DiffEditor\\DiffEditor.tsx","C:\\Users\\hp\\Desktop\\AlgorithmVisualizer-master\\node_modules\\@monaco-editor\\react\\src\\MonacoContainer\\index.ts","C:\\Users\\hp\\Desktop\\AlgorithmVisualizer-master\\node_modules\\@monaco-editor\\react\\src\\MonacoContainer\\MonacoContainer.tsx","C:\\Users\\hp\\Desktop\\AlgorithmVisualizer-master\\node_modules\\@monaco-editor\\react\\src\\MonacoContainer\\styles.ts","C:\\Users\\hp\\Desktop\\AlgorithmVisualizer-master\\node_modules\\@monaco-editor\\react\\src\\Loading\\Loading.tsx","C:\\Users\\hp\\Desktop\\AlgorithmVisualizer-master\\node_modules\\@monaco-editor\\react\\src\\Loading\\styles.ts","C:\\Users\\hp\\Desktop\\AlgorithmVisualizer-master\\node_modules\\@monaco-editor\\react\\src\\Loading\\index.ts","C:\\Users\\hp\\Desktop\\AlgorithmVisualizer-master\\node_modules\\@monaco-editor\\react\\src\\hooks\\useMount\\index.ts","C:\\Users\\hp\\Desktop\\AlgorithmVisualizer-master\\node_modules\\@monaco-editor\\react\\src\\hooks\\useUpdate\\index.ts","C:\\Users\\hp\\Desktop\\AlgorithmVisualizer-master\\node_modules\\@monaco-editor\\react\\src\\utils\\index.ts","C:\\Users\\hp\\Desktop\\AlgorithmVisualizer-master\\node_modules\\@monaco-editor\\react\\src\\hooks\\useMonaco\\index.ts","C:\\Users\\hp\\Desktop\\AlgorithmVisualizer-master\\node_modules\\@monaco-editor\\react\\src\\Editor\\index.ts","C:\\Users\\hp\\Desktop\\AlgorithmVisualizer-master\\node_modules\\@monaco-editor\\react\\src\\Editor\\Editor.tsx","C:\\Users\\hp\\Desktop\\AlgorithmVisualizer-master\\node_modules\\@monaco-editor\\react\\src\\hooks\\usePrevious\\index.ts"],"sourcesContent":["import loader from '@monaco-editor/loader';\nexport { loader };\n\nimport DiffEditor from './DiffEditor';\nexport * from './DiffEditor/types';\nexport { DiffEditor };\n\nimport useMonaco from './hooks/useMonaco';\nexport { useMonaco };\n\nimport Editor from './Editor';\nexport * from './Editor/types';\nexport { Editor };\nexport default Editor;\n\n// Monaco\nimport type * as monaco from 'monaco-editor/esm/vs/editor/editor.api';\nexport type Monaco = typeof monaco;\n\n// Default themes\nexport type Theme = 'vs-dark' | 'light';\n","import { memo } from 'react';\n\nimport DiffEditor from './DiffEditor';\n\nexport * from './types';\n\nexport default memo(DiffEditor);\n","import React, { useState, useRef, useCallback, useEffect } from 'react';\nimport loader from '@monaco-editor/loader';\n\nimport MonacoContainer from '../MonacoContainer';\nimport useMount from '../hooks/useMount';\nimport useUpdate from '../hooks/useUpdate';\nimport { noop, getOrCreateModel } from '../utils';\nimport { type DiffEditorProps, type MonacoDiffEditor } from './types';\nimport { type Monaco } from '..';\n\nfunction DiffEditor({\n  original,\n  modified,\n  language,\n  originalLanguage,\n  modifiedLanguage,\n  originalModelPath,\n  modifiedModelPath,\n  keepCurrentOriginalModel = false,\n  keepCurrentModifiedModel = false,\n  theme = 'light',\n  loading = 'Loading...',\n  options = {},\n  height = '100%',\n  width = '100%',\n  className,\n  wrapperProps = {},\n  beforeMount = noop,\n  onMount = noop,\n}: DiffEditorProps) {\n  const [isEditorReady, setIsEditorReady] = useState(false);\n  const [isMonacoMounting, setIsMonacoMounting] = useState(true);\n  const editorRef = useRef<MonacoDiffEditor | null>(null);\n  const monacoRef = useRef<Monaco | null>(null);\n  const containerRef = useRef<HTMLDivElement>(null);\n  const onMountRef = useRef(onMount);\n  const beforeMountRef = useRef(beforeMount);\n  const preventCreation = useRef(false);\n\n  useMount(() => {\n    const cancelable = loader.init();\n\n    cancelable\n      .then((monaco) => (monacoRef.current = monaco) && setIsMonacoMounting(false))\n      .catch(\n        (error) =>\n          error?.type !== 'cancelation' && console.error('Monaco initialization: error:', error),\n      );\n\n    return () => (editorRef.current ? disposeEditor() : cancelable.cancel());\n  });\n\n  useUpdate(\n    () => {\n      if (editorRef.current && monacoRef.current) {\n        const originalEditor = editorRef.current.getOriginalEditor();\n        const model = getOrCreateModel(\n          monacoRef.current,\n          original || '',\n          originalLanguage || language || 'text',\n          originalModelPath || '',\n        );\n\n        if (model !== originalEditor.getModel()) {\n          originalEditor.setModel(model);\n        }\n      }\n    },\n    [originalModelPath],\n    isEditorReady,\n  );\n\n  useUpdate(\n    () => {\n      if (editorRef.current && monacoRef.current) {\n        const modifiedEditor = editorRef.current.getModifiedEditor();\n        const model = getOrCreateModel(\n          monacoRef.current,\n          modified || '',\n          modifiedLanguage || language || 'text',\n          modifiedModelPath || '',\n        );\n\n        if (model !== modifiedEditor.getModel()) {\n          modifiedEditor.setModel(model);\n        }\n      }\n    },\n    [modifiedModelPath],\n    isEditorReady,\n  );\n\n  useUpdate(\n    () => {\n      const modifiedEditor = editorRef.current!.getModifiedEditor();\n      if (modifiedEditor.getOption(monacoRef.current!.editor.EditorOption.readOnly)) {\n        modifiedEditor.setValue(modified || '');\n      } else {\n        if (modified !== modifiedEditor.getValue()) {\n          modifiedEditor.executeEdits('', [\n            {\n              range: modifiedEditor.getModel()!.getFullModelRange(),\n              text: modified || '',\n              forceMoveMarkers: true,\n            },\n          ]);\n\n          modifiedEditor.pushUndoStop();\n        }\n      }\n    },\n    [modified],\n    isEditorReady,\n  );\n\n  useUpdate(\n    () => {\n      editorRef.current?.getModel()?.original.setValue(original || '');\n    },\n    [original],\n    isEditorReady,\n  );\n\n  useUpdate(\n    () => {\n      const { original, modified } = editorRef.current!.getModel()!;\n\n      monacoRef.current!.editor.setModelLanguage(original, originalLanguage || language || 'text');\n      monacoRef.current!.editor.setModelLanguage(modified, modifiedLanguage || language || 'text');\n    },\n    [language, originalLanguage, modifiedLanguage],\n    isEditorReady,\n  );\n\n  useUpdate(\n    () => {\n      monacoRef.current?.editor.setTheme(theme);\n    },\n    [theme],\n    isEditorReady,\n  );\n\n  useUpdate(\n    () => {\n      editorRef.current?.updateOptions(options);\n    },\n    [options],\n    isEditorReady,\n  );\n\n  const setModels = useCallback(() => {\n    if (!monacoRef.current) return;\n    beforeMountRef.current(monacoRef.current);\n    const originalModel = getOrCreateModel(\n      monacoRef.current,\n      original || '',\n      originalLanguage || language || 'text',\n      originalModelPath || '',\n    );\n\n    const modifiedModel = getOrCreateModel(\n      monacoRef.current,\n      modified || '',\n      modifiedLanguage || language || 'text',\n      modifiedModelPath || '',\n    );\n\n    editorRef.current?.setModel({\n      original: originalModel,\n      modified: modifiedModel,\n    });\n  }, [\n    language,\n    modified,\n    modifiedLanguage,\n    original,\n    originalLanguage,\n    originalModelPath,\n    modifiedModelPath,\n  ]);\n\n  const createEditor = useCallback(() => {\n    if (!preventCreation.current && containerRef.current) {\n      editorRef.current = monacoRef.current!.editor.createDiffEditor(containerRef.current, {\n        automaticLayout: true,\n        ...options,\n      });\n\n      setModels();\n\n      monacoRef.current?.editor.setTheme(theme);\n\n      setIsEditorReady(true);\n      preventCreation.current = true;\n    }\n  }, [options, theme, setModels]);\n\n  useEffect(() => {\n    if (isEditorReady) {\n      onMountRef.current(editorRef.current!, monacoRef.current!);\n    }\n  }, [isEditorReady]);\n\n  useEffect(() => {\n    !isMonacoMounting && !isEditorReady && createEditor();\n  }, [isMonacoMounting, isEditorReady, createEditor]);\n\n  function disposeEditor() {\n    const models = editorRef.current?.getModel();\n\n    if (!keepCurrentOriginalModel) {\n      models?.original?.dispose();\n    }\n\n    if (!keepCurrentModifiedModel) {\n      models?.modified?.dispose();\n    }\n\n    editorRef.current?.dispose();\n  }\n\n  return (\n    <MonacoContainer\n      width={width}\n      height={height}\n      isEditorReady={isEditorReady}\n      loading={loading}\n      _ref={containerRef}\n      className={className}\n      wrapperProps={wrapperProps}\n    />\n  );\n}\n\nexport default DiffEditor;\n","import { memo } from 'react';\n\nimport MonacoContainer from './MonacoContainer';\n\nexport default memo(MonacoContainer);\n","import React from 'react';\n\nimport styles from './styles';\nimport Loading from '../Loading';\nimport { type ContainerProps } from './types';\n\n// ** forwardref render functions do not support proptypes or defaultprops **\n// one of the reasons why we use a separate prop for passing ref instead of using forwardref\n\nfunction MonacoContainer({\n  width,\n  height,\n  isEditorReady,\n  loading,\n  _ref,\n  className,\n  wrapperProps,\n}: ContainerProps) {\n  return (\n    <section style={{ ...styles.wrapper, width, height }} {...wrapperProps}>\n      {!isEditorReady && <Loading>{loading}</Loading>}\n      <div\n        ref={_ref}\n        style={{ ...styles.fullWidth, ...(!isEditorReady && styles.hide) }}\n        className={className}\n      />\n    </section>\n  );\n}\n\nexport default MonacoContainer;\n","import { type CSSProperties } from 'react';\n\nconst styles: Record<string, CSSProperties> = {\n  wrapper: {\n    display: 'flex',\n    position: 'relative',\n    textAlign: 'initial',\n  },\n  fullWidth: {\n    width: '100%',\n  },\n  hide: {\n    display: 'none',\n  },\n};\n\nexport default styles;\n","import React, { type PropsWithChildren } from 'react';\n\nimport styles from './styles';\n\nfunction Loading({ children }: PropsWithChildren) {\n  return <div style={styles.container}>{children}</div>;\n}\n\nexport default Loading;\n","import { type CSSProperties } from 'react';\n\nconst styles: Record<string, CSSProperties> = {\n  container: {\n    display: 'flex',\n    height: '100%',\n    width: '100%',\n    justifyContent: 'center',\n    alignItems: 'center',\n  },\n};\n\nexport default styles;\n","import Loading from './Loading';\n\nexport default Loading;\n","import { useEffect, type EffectCallback } from 'react';\n\nfunction useMount(effect: EffectCallback) {\n  useEffect(effect, []);\n}\n\nexport default useMount;\n","import { useEffect, useRef, type DependencyList, type EffectCallback } from 'react';\n\nfunction useUpdate(effect: EffectCallback, deps: DependencyList, applyChanges = true) {\n  const isInitialMount = useRef(true);\n\n  useEffect(\n    isInitialMount.current || !applyChanges\n      ? () => {\n          isInitialMount.current = false;\n        }\n      : effect,\n    deps,\n  );\n}\n\nexport default useUpdate;\n","import { type Monaco } from '..';\n\n/**\n * noop is a helper function that does nothing\n * @returns undefined\n */\nfunction noop() {\n  /** no-op */\n}\n\n/**\n * getOrCreateModel is a helper function that will return a model if it exists\n * or create a new model if it does not exist.\n * This is useful for when you want to create a model for a file that may or may not exist yet.\n * @param monaco The monaco instance\n * @param value The value of the model\n * @param language The language of the model\n * @param path The path of the model\n * @returns The model that was found or created\n */\nfunction getOrCreateModel(monaco: Monaco, value: string, language: string, path: string) {\n  return getModel(monaco, path) || createModel(monaco, value, language, path);\n}\n\n/**\n * getModel is a helper function that will return a model if it exists\n * or return undefined if it does not exist.\n * @param monaco The monaco instance\n * @param path The path of the model\n * @returns The model that was found or undefined\n */\nfunction getModel(monaco: Monaco, path: string) {\n  return monaco.editor.getModel(createModelUri(monaco, path));\n}\n\n/**\n * createModel is a helper function that will create a new model\n * @param monaco The monaco instance\n * @param value The value of the model\n * @param language The language of the model\n * @param path The path of the model\n * @returns The model that was created\n */\nfunction createModel(monaco: Monaco, value: string, language?: string, path?: string) {\n  return monaco.editor.createModel(\n    value,\n    language,\n    path ? createModelUri(monaco, path) : undefined,\n  );\n}\n\n/**\n * createModelUri is a helper function that will create a new model uri\n * @param monaco The monaco instance\n * @param path The path of the model\n * @returns The model uri that was created\n */\nfunction createModelUri(monaco: Monaco, path: string) {\n  return monaco.Uri.parse(path);\n}\n\nexport { noop, getOrCreateModel };\n","import { useState } from 'react';\nimport loader from '@monaco-editor/loader';\n\nimport useMount from '../useMount';\n\nfunction useMonaco() {\n  const [monaco, setMonaco] = useState(loader.__getMonacoInstance());\n\n  useMount(() => {\n    let cancelable: ReturnType<typeof loader.init>;\n\n    if (!monaco) {\n      cancelable = loader.init();\n\n      cancelable.then((monaco) => {\n        setMonaco(monaco);\n      });\n    }\n\n    return () => cancelable?.cancel();\n  });\n\n  return monaco;\n}\n\nexport default useMonaco;\n","import { memo } from 'react';\n\nimport Editor from './Editor';\n\nexport * from './types';\n\nexport default memo(Editor);\n","import React, { useState, useEffect, useRef, useCallback } from 'react';\nimport loader from '@monaco-editor/loader';\nimport useMount from '../hooks/useMount';\nimport useUpdate from '../hooks/useUpdate';\nimport usePrevious from '../hooks/usePrevious';\nimport { type IDisposable, type editor } from 'monaco-editor';\nimport { noop, getOrCreateModel } from '../utils';\nimport { type EditorProps } from './types';\nimport { type Monaco } from '..';\nimport MonacoContainer from '../MonacoContainer';\n\nconst viewStates = new Map();\n\nfunction Editor({\n  defaultValue,\n  defaultLanguage,\n  defaultPath,\n  value,\n  language,\n  path,\n  /* === */\n  theme = 'light',\n  line,\n  loading = 'Loading...',\n  options = {},\n  overrideServices = {},\n  saveViewState = true,\n  keepCurrentModel = false,\n  /* === */\n  width = '100%',\n  height = '100%',\n  className,\n  wrapperProps = {},\n  /* === */\n  beforeMount = noop,\n  onMount = noop,\n  onChange,\n  onValidate = noop,\n}: EditorProps) {\n  const [isEditorReady, setIsEditorReady] = useState(false);\n  const [isMonacoMounting, setIsMonacoMounting] = useState(true);\n  const monacoRef = useRef<Monaco | null>(null);\n  const editorRef = useRef<editor.IStandaloneCodeEditor | null>(null);\n  const containerRef = useRef<HTMLDivElement>(null);\n  const onMountRef = useRef(onMount);\n  const beforeMountRef = useRef(beforeMount);\n  const subscriptionRef = useRef<IDisposable>();\n  const valueRef = useRef(value);\n  const previousPath = usePrevious(path);\n  const preventCreation = useRef(false);\n  const preventTriggerChangeEvent = useRef<boolean>(false);\n\n  useMount(() => {\n    const cancelable = loader.init();\n\n    cancelable\n      .then((monaco) => (monacoRef.current = monaco) && setIsMonacoMounting(false))\n      .catch(\n        (error) =>\n          error?.type !== 'cancelation' && console.error('Monaco initialization: error:', error),\n      );\n\n    return () => (editorRef.current ? disposeEditor() : cancelable.cancel());\n  });\n\n  useUpdate(\n    () => {\n      const model = getOrCreateModel(\n        monacoRef.current!,\n        defaultValue || value || '',\n        defaultLanguage || language || '',\n        path || defaultPath || '',\n      );\n\n      if (model !== editorRef.current?.getModel()) {\n        if (saveViewState) viewStates.set(previousPath, editorRef.current?.saveViewState());\n        editorRef.current?.setModel(model);\n        if (saveViewState) editorRef.current?.restoreViewState(viewStates.get(path));\n      }\n    },\n    [path],\n    isEditorReady,\n  );\n\n  useUpdate(\n    () => {\n      editorRef.current?.updateOptions(options);\n    },\n    [options],\n    isEditorReady,\n  );\n\n  useUpdate(\n    () => {\n      if (!editorRef.current || value === undefined) return;\n      if (editorRef.current.getOption(monacoRef.current!.editor.EditorOption.readOnly)) {\n        editorRef.current.setValue(value);\n      } else if (value !== editorRef.current.getValue()) {\n        preventTriggerChangeEvent.current = true;\n        editorRef.current.executeEdits('', [\n          {\n            range: editorRef.current.getModel()!.getFullModelRange(),\n            text: value,\n            forceMoveMarkers: true,\n          },\n        ]);\n\n        editorRef.current.pushUndoStop();\n        preventTriggerChangeEvent.current = false;\n      }\n    },\n    [value],\n    isEditorReady,\n  );\n\n  useUpdate(\n    () => {\n      const model = editorRef.current?.getModel();\n      if (model && language) monacoRef.current?.editor.setModelLanguage(model, language);\n    },\n    [language],\n    isEditorReady,\n  );\n\n  useUpdate(\n    () => {\n      // reason for undefined check: https://github.com/suren-atoyan/monaco-react/pull/188\n      if (line !== undefined) {\n        editorRef.current?.revealLine(line);\n      }\n    },\n    [line],\n    isEditorReady,\n  );\n\n  useUpdate(\n    () => {\n      monacoRef.current?.editor.setTheme(theme);\n    },\n    [theme],\n    isEditorReady,\n  );\n\n  const createEditor = useCallback(() => {\n    if (!containerRef.current || !monacoRef.current) return;\n    if (!preventCreation.current) {\n      beforeMountRef.current(monacoRef.current);\n      const autoCreatedModelPath = path || defaultPath;\n\n      const defaultModel = getOrCreateModel(\n        monacoRef.current,\n        value || defaultValue || '',\n        defaultLanguage || language || '',\n        autoCreatedModelPath || '',\n      );\n\n      editorRef.current = monacoRef.current?.editor.create(\n        containerRef.current,\n        {\n          model: defaultModel,\n          automaticLayout: true,\n          ...options,\n        },\n        overrideServices,\n      );\n\n      saveViewState && editorRef.current.restoreViewState(viewStates.get(autoCreatedModelPath));\n\n      monacoRef.current.editor.setTheme(theme);\n\n      setIsEditorReady(true);\n      preventCreation.current = true;\n    }\n  }, [\n    defaultValue,\n    defaultLanguage,\n    defaultPath,\n    value,\n    language,\n    path,\n    options,\n    overrideServices,\n    saveViewState,\n    theme,\n  ]);\n\n  useEffect(() => {\n    if (isEditorReady) {\n      onMountRef.current(editorRef.current!, monacoRef.current!);\n    }\n  }, [isEditorReady]);\n\n  useEffect(() => {\n    !isMonacoMounting && !isEditorReady && createEditor();\n  }, [isMonacoMounting, isEditorReady, createEditor]);\n\n  // subscription\n  // to avoid unnecessary updates (attach - dispose listener) in subscription\n  valueRef.current = value;\n\n  // onChange\n  useEffect(() => {\n    if (isEditorReady && onChange) {\n      subscriptionRef.current?.dispose();\n      subscriptionRef.current = editorRef.current?.onDidChangeModelContent((event) => {\n        if (!preventTriggerChangeEvent.current) {\n          onChange(editorRef.current!.getValue(), event);\n        }\n      });\n    }\n  }, [isEditorReady, onChange]);\n\n  // onValidate\n  useEffect(() => {\n    if (isEditorReady) {\n      const changeMarkersListener = monacoRef.current!.editor.onDidChangeMarkers((uris) => {\n        const editorUri = editorRef.current!.getModel()?.uri;\n\n        if (editorUri) {\n          const currentEditorHasMarkerChanges = uris.find((uri) => uri.path === editorUri.path);\n          if (currentEditorHasMarkerChanges) {\n            const markers = monacoRef.current!.editor.getModelMarkers({\n              resource: editorUri,\n            });\n            onValidate?.(markers);\n          }\n        }\n      });\n\n      return () => {\n        changeMarkersListener?.dispose();\n      };\n    }\n    return () => {\n      // eslint happy\n    };\n  }, [isEditorReady, onValidate]);\n\n  function disposeEditor() {\n    subscriptionRef.current?.dispose();\n\n    if (keepCurrentModel) {\n      saveViewState && viewStates.set(path, editorRef.current!.saveViewState());\n    } else {\n      editorRef.current!.getModel()?.dispose();\n    }\n\n    editorRef.current!.dispose();\n  }\n\n  return (\n    <MonacoContainer\n      width={width}\n      height={height}\n      isEditorReady={isEditorReady}\n      loading={loading}\n      _ref={containerRef}\n      className={className}\n      wrapperProps={wrapperProps}\n    />\n  );\n}\n\nexport default Editor;\n","import { useEffect, useRef } from 'react';\n\nfunction usePrevious<T>(value: T) {\n  const ref = useRef<T>();\n\n  useEffect(() => {\n    ref.current = value;\n  }, [value]);\n\n  return ref.current;\n}\n\nexport default usePrevious;\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}